
/*
   DO NOT EDIT THIS FILE!

   This file is automatically generated by hpy.tools.autogen.hpyslot.universal_autogen_hpytype_checkslot_h
   See also hpy.tools.autogen and hpy/tools/public_api.h

   Run this to regenerate:
       make autogen

*/

_HPy_UNUSED static inline int
_HPyType_CheckSlot(HPy type, HPyDef *value)
{
    PyTypeObject *t = (PyTypeObject *) _h2py(type);
    void *tmp;
    char msg[64];
    switch (value->slot.slot) {
    case HPy_nb_absolute:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_absolute == (void*) value->slot.cpy_trampoline;
    case HPy_nb_add:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_add == (void*) value->slot.cpy_trampoline;
    case HPy_nb_and:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_and == (void*) value->slot.cpy_trampoline;
    case HPy_nb_bool:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_bool == (void*) value->slot.cpy_trampoline;
    case HPy_nb_divmod:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_divmod == (void*) value->slot.cpy_trampoline;
    case HPy_nb_float:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_float == (void*) value->slot.cpy_trampoline;
    case HPy_nb_floor_divide:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_floor_divide == (void*) value->slot.cpy_trampoline;
    case HPy_nb_index:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_index == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_add:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_add == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_and:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_and == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_floor_divide:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_floor_divide == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_lshift:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_lshift == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_multiply:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_multiply == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_or:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_or == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_power:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_power == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_remainder:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_remainder == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_rshift:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_rshift == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_subtract:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_subtract == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_true_divide:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_true_divide == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_xor:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_xor == (void*) value->slot.cpy_trampoline;
    case HPy_nb_int:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_int == (void*) value->slot.cpy_trampoline;
    case HPy_nb_invert:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_invert == (void*) value->slot.cpy_trampoline;
    case HPy_nb_lshift:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_lshift == (void*) value->slot.cpy_trampoline;
    case HPy_nb_multiply:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_multiply == (void*) value->slot.cpy_trampoline;
    case HPy_nb_negative:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_negative == (void*) value->slot.cpy_trampoline;
    case HPy_nb_or:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_or == (void*) value->slot.cpy_trampoline;
    case HPy_nb_positive:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_positive == (void*) value->slot.cpy_trampoline;
    case HPy_nb_power:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_power == (void*) value->slot.cpy_trampoline;
    case HPy_nb_remainder:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_remainder == (void*) value->slot.cpy_trampoline;
    case HPy_nb_rshift:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_rshift == (void*) value->slot.cpy_trampoline;
    case HPy_nb_subtract:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_subtract == (void*) value->slot.cpy_trampoline;
    case HPy_nb_true_divide:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_true_divide == (void*) value->slot.cpy_trampoline;
    case HPy_nb_xor:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_xor == (void*) value->slot.cpy_trampoline;
    case HPy_nb_matrix_multiply:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_matrix_multiply == (void*) value->slot.cpy_trampoline;
    case HPy_nb_inplace_matrix_multiply:
            return t->tp_as_number != NULL && (void*) t->tp_as_number->nb_inplace_matrix_multiply == (void*) value->slot.cpy_trampoline;
    default:
        tmp = PyType_GetSlot(t, (int) value->slot.slot);
        if (tmp == NULL && PyErr_Occurred()) {
            PyErr_Clear();
            snprintf(msg, sizeof(msg), "Unsupported slot in HPyType_CheckSlot: %d", value->slot.slot);
            Py_FatalError(msg);
        }
        return tmp == (void*) value->slot.cpy_trampoline;
    }
}
